[ { "title": "BLE control interface", "url": "/posts/BLE/", "categories": "", "tags": "", "date": "2023-07-24 00:00:00 -0400", "snippet": "The normal interface to the PHL is through a WiFi connection using the TCP/IP protocol. The PHL also has a BLE interface with an corresponding PC program that functions as an example of how a BLE interface could be developed for the PHL system. In the latest PHL images there’s a problem with the interface - a Node.js version issue. Until a more permanent fix is available, it’s possible to get the BLE running on the PHL by copying some files to the device manually.The peripheral end of the program is on the PHL at /usr/share/mahalia-ble-peripheral.js and it translates BLE data to the openMHA process via a socket interface. The directory /usr/share/mahalia-ble-peripherals/node-modules contains the files that need to be updated, along with the mahalia-ble-peripheral.js program itself.How to update PHL1) Download updated files, ble_buster.tar.gz and mahalia-ble-peripherals.js.https://github.com/BC-support/BLE-Peripheral 2) Connect host computer to the PHL via WiFi.3) ssh into the PHL and delete the existing node_module files with/usr/share/mahalia-ble-peripheral/node_modules$ sudo rm -rf *4) Copy files from host to PHL. Note the root user password is ‘toor’.scp mahalia-ble-peripheral.js root@10.0.0.1:/usr/share/mahalia-ble-peripheral scp ble_buster.tar.gz root@10.0.0.1:/usr/share/mahalia-ble-peripheral/node_modules5) On PHL, uncompress files/usr/share/mahalia-ble-peripheral/node_modules/sudo tar -xf ble_buster.tar.gz6) Restart PHL.Host PC interfaceThe code for server side of the BLE connection has changed slightly and the new repository is at https://github.com/BC-support/BLE-ServerThe installation and operation instructions are also there." }, { "title": "Example EMA system", "url": "/posts/EMA/", "categories": "", "tags": "", "date": "2023-04-18 00:00:00 -0400", "snippet": "The PHL has the capability to serve as an Ecological Momentary Assesment system that can capture real-time data from subjects as they go about their daily lives. The very basic system described here shows a few simple techniques that can serve as a starting point for development of an EMA for specific research areas. This example also shows how to play .wav files stored on the PHL, a function that might not normally be associated with EMA systems but could useful nevertheless.The Node Red user interface is used in this example as it is the standard GUI used on the PHL. Other frameworks could be used, like Python, and the general methods shown here could be adapted.The files for this project are located at: https://github.com/BC-support/EMASetting the correct date and timeEMA systems typically save a lot of data at various times throughout the day so it’s usually important for the EMA to associate any saved data with a timestamp. The current PHL doesn’t have a real time clock, so the time needs to be set whenever the device is powered up. If this isn’t done there will be a time and date available, but it will be incorrect.The example system described here provides a way to set the correct time and date through the Node Red GUI interface. The time is read from the system running the GUI (smartphone, computer, etc.) and sent to the PHL.Main system componentsEMA.cfgThe signal processing here is a very bare bones multiband compressor with omni mics. The same techniques could be applied to more complex algorithms.RMS Measurement: From ‘rmslevel’ plugin.Save RMS: Uses ‘acrec’ plugin.Play .wav file: Replaces mic signal with .wav file source using ‘wavplay’ plugin.Record Mic Signals: Saves mic signals to .wav file using ‘wavrec’ plugin.Multiband Compressor: Simple 5 band compressor that processes mic signals or .wav file sources.Node Red interfaceThe GUI in this example is centered around a simple dropdown menu that allows the user to rate the noise level of their current environment. The Node Red controls are configured to save several seconds of the RMS level when a noise level is chosen. This is done by setting the ‘record’ variable of the acrec plugin to ‘yes’ for a short interval. As the plugin documentation describes, a new data file is created and saved for each cycle of the ‘record’ variable going from yes to no. The noise level ratings are saved to a single text file with a time stamp that matches the RMS data file time. Each noise level rating is stored on a separate line in the file. This is accomplished with the ‘file’ node and is easy to modify to store whatever data or information is required.The Play tab has a slider button that plays .wav files stored on the PHL. This is a very simple framework that cycles through the files. The .wav data replaces the mic signals and is processed by the compressor. This example switches back to the mic signal and resets the slider after 3 seconds, so the stored speech samples are limited to this duration.The Record tab has two slider switches that illustrate how the RMS and mic signals can be saved. Since this example saves the RMS levels automatically when the noise level rating is set, these controls aren’t strictly necessary. The sliders are reset after an arbitrary time interval.The Home tab button to set the time on the PHL uses the ‘this.scope.action’ commands to get the time from the smartphone or PC, instead of the PHL, which is important.Data handlingThe recorded RMS data is stored in .dat files on the PHL. These files can be downloaded to a host PC and analyzed. A simple Python program is included here that shows how to read the binary data, stored as a double data type, and convert it to text format. The plot here shows an example of saved microphone levels with a tone source next to the right microphone.The noise levels are stored in the previously described text file.level2 at Fri Apr 14 2023 14:48:56 GMT+0000 (Coordinated Universal Time) level4 at Fri Apr 14 2023 14:49:00 GMT+0000 (Coordinated Universal Time) level1 at Fri Apr 14 2023 14:49:03 GMT+0000 (Coordinated Universal Time) level3 at Fri Apr 14 2023 14:49:07 GMT+0000 (Coordinated Universal Time) Going forwardThe simple example system here shows general methods of how the PHL can be used to investigate a subject’s experience with different soundscapes. Compared to a smartphone based EMA with regular hearing aids, the PHL has to ability to record more of the true acoustic data present in an environment. Many preference assessments could be moved from simulated lab settings to real-world cafeterias, homes, cars, etc. Hearing researchers will be able to imagine many variations of the example system laid out here." }, { "title": "Using the Apple Watch as a PHL Interface", "url": "/posts/watch/", "categories": "", "tags": "", "date": "2023-01-24 00:00:00 -0500", "snippet": "It’s possible to connect an Apple watch to the PHL and then control parameters using the watch screen. The connection is via WiFi and it takes a few slightly inconvenient work arounds, but it is possible to replace the phone or computer with this smaller interface device.Apple Watch browserWhen using the Node Red interface from a computer or phone the GUI is accessed by opening a browser and pointing it to the address ‘http://10.0.0.1:1880/ui’. The watch uses the same method, but this is difficult to do because the Apple Watch doesn’t come with a web browser and even if you install one, typing anything on the watch is tedious and error prone.One of the easiest ways to get around this is to email yourself the link, ‘http://10.0.0.1:1880/ui’. Reading the email from the watch then selecting the link will launch a browser and you’ll be taken to the interface.New Node Red interfaceOnce you’ve connected, the current standard GUI will run on the watch but the small screen makes it difficult to use. The basic steps to generate a new Node Red interface are as follows: In the directory /etc/mahalia/nodered, delete the file openMHAcontrol.flow Restart PHL, (or restart mahalia-nodered service). Connect host computer to PHL via WiFi Open link ‘http://10.0.0.1:1880’ Use the Node Red GUI to add your own controls Connect the watch to the PHL via WiFi and open the link (described above) to your new GUIThe details of designing a Node Red interface will be reviewed in another post, but a good way to learn is by examining the existing interfaces that come with the PHL. Run a configuration, then connect to ‘http://10.0.0.1:1880’ to see the controls.Example screenThe dummy screen shown here consists of 2 large buttons and a slider along the bottom edge. The buttons here are size 3x3 on the Node Red layout grid. The slider is functional but feels small and not that easy to use. The screen size is maximized by removing some tab labels and titles (In ‘dashboard’, Site-&gt;Options-&gt; Hide the title bar). The Node Red framework provides a lot of flexibility for developing useful minimal interfaces within the constraints imposed by the small screen." }, { "title": "Mic Array using the Connection Square", "url": "/posts/Mic-Array-with-Connection-Square/", "categories": "", "tags": "", "date": "2022-12-09 00:00:00 -0500", "snippet": "By using the Connection Square with the PHL it’s possible to create systems with experimental mic and speaker configuratons for the PHL. Connection Square BasicsWhen connected to the PHL, the Connection Square provides convenient access to the inputs and outputs of the onboard codecs. Custom transducers can then be used to run using the openMHA platform.Mic Array exampleA 6 microphone array was constructed to show how the Connection Square can be used for novel transducer configurations. The configuration here is referred to as ‘PHL Expansion Mode’. The mic array described in this example is actually and endfire array, instead of the circular array shown here. HardwareThere are 6 MEMS mics (TDK InvenSense ICS-40730) on the board in an endfire array. The bias voltage comes from the Connection Square. Each connector leads to a stereo cable carrying the signals from two mics. The microphones are spaced approximately 14mm apart in this example. SoftwareThis array uses custom software running on the PHL to create a fixed beamformer. The phase and magnitude of each mic signal is adjusted by an FIR filter. A gain stage allows calibration of individual mic sensitivity if that’s required, then the signals are summed. The FIR filters here are actually part of the transducers plugin, originally designed to aid in calibration. The output is sent to both channels of the third output, arbitrarily.The .cfg file is included here.nchannels_in = 8fragsize = 64srate = 24000iolib=MHAIOalsaio.in.device=hw:0io.out.device=hw:0io.priority=90# MHA library namemhalib = mhachain mha.algos=[route:sort_input transducers route:sort_output]mha.transducers.plugin_name=mhachainmha.transducers.mhachain.algos=[gain matrixmixer:mix]mha.transducers.mhachain.gain.max = 30 mha.transducers.mhachain.gain.gains = [27 27 27 28 27 27]mha.transducers.mhachain.mix.m = [ [1 1 1 1 1 1];[1 1 1 1 1 1]]# L1 R1 L2 R1mha.sort_input.out=[:0 :4 :1 :5 :2 :6]# Output jacks: L1,R1 L2,R2.... # L1 L2 L3 R1 R2 R3mha.sort_output.out=[:0 :1 :0 :0 :0 :1 :1 :0]mha.transducers.calib_in.peaklevel= [ 110 110 110 110 110 110] mha.transducers.calib_out.peaklevel= [ 110 110] mha.transducers.calib_in.fir=[ [ -2.0032705e-002 -2.3638943e-002 -2.3407507e-002 -2.7283196e-002 -2.5968680e-002 -2.8455644e-002 -2.2191306e-002 -1.6503569e-002 -1.4049329e-002 -2.5585308e-002 -1.5882651e-002 -3.5499336e-002 -2.1440464e-002 -5.6538020e-002 -3.6359777e-002 -1.5291555e-001 5.7208083e-002 1.3251913e-001 8.7456740e-002 7.5830771e-002 5.7627669e-002 5.0586961e-002 4.1289400e-002 3.7132495e-002 3.1232869e-002 2.9283061e-002 2.4057189e-002 2.4124868e-002 2.1146991e-002 2.1617832e-002 1.8997895e-002 1.9288759e-02]; [-1.2921051e-002 -1.0815475e-002 -1.5027884e-002 -1.2559416e-002 -1.7992861e-002 -1.6032973e-002 -2.6900000e-002 -2.7028918e-002 -1.9084987e-002 -1.0965706e-002 -2.7643674e-002 -9.4356088e-003 -4.0970806e-002 -9.5641182e-003 -9.1450520e-002 1.8218163e-001 1.1474769e-001 -2.7555076e-002 2.0131688e-002 1.8794221e-002 2.6983643e-002 2.0736556e-002 2.3291749e-002 1.7921743e-002 2.0021979e-002 1.4423846e-002 1.8233951e-002 1.3804314e-002 1.5978022e-002 1.1889940e-002 1.3775518e-002 1.0224069e-002 ]; [ -2.9337349e-004 -4.5416671e-003 -3.3179818e-004 -6.0493662e-003 -2.2718896e-003 -1.2668948e-002 -9.0920683e-003 -2.1427272e-002 -2.6266453e-002 -1.8173500e-002 -2.2602410e-003 -2.7233117e-002 1.0890779e-002 -5.1395279e-002 2.2138448e-001 8.1866833e-002 -2.2879966e-002 2.5400160e-002 -3.4029918e-002 -7.1051944e-003 -6.3543145e-003 4.9190927e-003 1.4021763e-003 8.0684528e-003 2.9012123e-003 1.0121262e-002 4.5649655e-003 9.2480286e-003 4.1416286e-003 7.6826227e-003 3.1508372e-003 6.3661305e-003 ]; [ 4.0999047e-003 9.8278190e-003 4.2831620e-003 1.0087164e-002 1.2381191e-003 9.2201579e-003 -1.3835354e-003 3.6794613e-003 -1.0481415e-002 -2.0191043e-002 -1.1562718e-002 2.2952279e-002 -2.0600479e-002 2.3467355e-001 4.6827744e-002 -3.7867854e-002 7.2745060e-003 -2.9214201e-002 4.2173615e-003 -3.4822246e-002 -1.7933332e-002 -1.8313195e-002 -6.8780478e-003 -1.0678976e-002 -2.4369339e-004 -6.3510636e-003 6.6164648e-004 -5.1971393e-003 3.9173786e-004 -4.6541555e-003 5.7634483e-005 -4.4184339e-003]; [ 1.8149771e-002 1.2753766e-002 2.0103743e-002 1.2902069e-002 2.3928415e-002 1.5619104e-002 2.7546069e-002 1.8478333e-002 2.9023099e-002 1.4933712e-002 -6.7112706e-004 1.1533634e-002 2.2702800e-001 -4.3866934e-003 -6.1797826e-002 -1.1285114e-002 -3.6038433e-002 -7.4003964e-003 -2.9795775e-002 -3.8450532e-003 -3.2305392e-002 -2.2590576e-002 -2.4947277e-002 -1.2382691e-002 -1.8982923e-002 -1.0076353e-002 -1.6162127e-002 -8.6911821e-003 -1.3942886e-002 -7.5397178e-003 -1.2074299e-002 -6.5215780e-003]; [ 1.9169444e-002 2.7968630e-002 2.2521196e-002 3.5308552e-002 2.9205967e-002 4.5147640e-002 4.0191016e-002 6.1334387e-002 5.9592067e-002 9.1590206e-002 9.9391086e-002 1.3624531e-001 -1.0326157e-001 -9.3200299e-002 -3.3306135e-002 -4.6919547e-002 -1.9113937e-002 -3.3418932e-002 -1.2274316e-002 -2.7867198e-002 -6.6117267e-003 -2.5818986e-002 -2.1430887e-002 -3.1786255e-002 -2.2647733e-002 -2.8917977e-002 -1.9957765e-002 -2.4863937e-002 -1.6914158e-002 -2.1153852e-002 -1.4252111e-002 -1.8044334e-002]]cmd=start" }, { "title": "Controlling the LED", "url": "/posts/Controlling-the-LEDs/", "categories": "", "tags": "leds", "date": "2022-11-14 00:00:00 -0500", "snippet": "This guide to controlling the LED on the PHL is courtesy of Hendrik Kayser, who knows the PHL inside and out. The push button is also used here to switch things on and off. The basic ideas are as follows: The LED is at ‘/sys/class/gpio/gpio49/value’ Send a 0 or 1 here to turn it OFF or ON. echo 0 /sys/class/gpio/gpio49/value # turn LED OFFecho 1 /sys/class/gpio/gpio49/value # turn LED ON The pushbutton is at ‘/sys/class/gpio/gpio115/value’ This value is 0 when the button is pushed. if [ \"$(cat /sys/class/gpio/gpio115/value)\" == \"0\" ]; then... The following three examples show how the LED and push button can be used with the generic hearing aid algorithm in the PHL. The techniques can be applied to other .cfg files as well.Bash script for the coherence filter# query state and store in variablestate=\"$(echo mha.transducers.mhachain.signal_processing.ola.c.coh.select?val | nc -q 0 localhost 33337)\"# remove the linebreak from openMHA's responsestate=\"${state//[$'\\n']}\"if [[ $state == \"coherence(MHA:success)\" ]]; then # COH is on, so turn it off. echo mha.transducers.mhachain.signal_processing.ola.c.coh.select=identity | nc -q 0 localhost 33337 sudo sh -c 'echo 0 &gt; /sys/class/gpio/gpio49/value'fiif [[ $state == \"identity(MHA:success)\" ]]; then # COH is off, so turn it on. echo mha.transducers.mhachain.signal_processing.ola.c.coh.select=coherence | nc -q 0 localhost 33337 sudo sh -c 'echo 1 &gt; /sys/class/gpio/gpio49/value'fiNote that the status is not propagated to the Node-Red GUI and that the ‘sudo sh -c’ is there to be able to switch the LED status as non-root user.Monitoring by the mahalia-batcat system serviceUsually, this service monitors the status of the push button and lights it up if pushed. Replacing the content of /usr/share/mahalia-utils/mahalia-batcat with the following bash code will power the button led whenever the bypass of the ADM in the generic hearing aid configuration is set to “0”. Drawback: It queries the state in mha periodically and not only triggered by a change in the configuration. Advantage: It queries the real state of mha, so it will not change the led in case a command the switch on/off the ADM failed.#!/usr/bin/env bash# set GPIO 1_17 to output (initally low)echo \"49\" &gt; /sys/class/gpio/exportecho out &gt; /sys/class/gpio/gpio49/directionecho 0 &gt; /sys/class/gpio/gpio49/value# set GPIO 3_19 to inputecho \"115\" &gt; /sys/class/gpio/exportecho in &gt; /sys/class/gpio/gpio115/direction# wait for AMD to changewhile true; do # query state of adm state=\"$(echo mha.transducers.mhachain.split.bte.adm.bypass?val | nc -q 0 localhost 33337)\" # remove the linebreak from openMHA's response state=\"${state//[$'\\n']}\" if [[ $state == \"0(MHA:success)\" ]]; then echo \"ADM on\" echo 1 &gt; /sys/class/gpio/gpio49/value fi if [[ $state == \"1(MHA:success)\" ]]; then echo \"ADM off\" echo 0 &gt; /sys/class/gpio/gpio49/value fi sleep 0.5sdoneNote that the status is not propagated to the Node-Red GUI and that the‘sudo sh -c’ is there to be able to switch the LED status as non-rootuser.Switch ADM status via push button#!/usr/bin/env bash# set GPIO 1_17 to output (initally low)echo \"49\" &gt; /sys/class/gpio/exportecho out &gt; /sys/class/gpio/gpio49/directionecho 0 &gt; /sys/class/gpio/gpio49/value# set GPIO 3_19 to inputecho \"115\" &gt; /sys/class/gpio/exportecho in &gt; /sys/class/gpio/gpio115/direction# wait for switch to be pressedwhile true; do if [ \"$(cat /sys/class/gpio/gpio115/value)\" == \"0\" ]; then echo \"switch is pressed!\" # query state of adm state=\"$(echo mha.transducers.mhachain.split.bte.adm.bypass?val | nc -q 0 localhost 33337)\" # remove the linebreak from openMHA's response state=\"${state//[$'\\n']}\" if [[ $state == \"0(MHA:success)\" ]]; then # ADM is on, so turn it off. echo mha.transducers.mhachain.split.bte.adm.bypass=1 | nc -q 0 localhost 33337 # Remember to switch decomb filter, too. echo mha.transducers.mhachain.signal_processing.ola.c.decomb.select=identity | nc -q 0 localhost 33337 echo 0 &gt; /sys/class/gpio/gpio49/value fi if [[ $state == \"1(MHA:success)\" ]]; then # ADM is off, so turn it on. \\ echo mha.transducers.mhachain.split.bte.adm.bypass=0 | nc -q 0 localhost 33337 # Remember to switch decomb filter, too. echo mha.transducers.mhachain.signal_processing.ola.c.decomb.select=equalize | nc -q 0 localhost 33337 echo 1 &gt; /sys/class/gpio/gpio49/value fi fi sleep 0.2sdone" }, { "title": "Input and output", "url": "/posts/Input-and-Output/", "categories": "", "tags": "", "date": "2022-11-06 00:00:00 -0400", "snippet": "When the standard BTE headset is connected to the PHL, there are 4 microphones and 2 receivers available to use, along with 2 line inputs and 2 line outputs. The ‘route’ plugin, which is documented in openMHA_plugins.pdf, determines the mapping between these external physical signals and the internal channels of the algorithm running in the PHL.Once you’re familiar with the ‘route’ plugin and you’ve seen a few examples it’s fairly easy to understand. Initially, however, there are a few quirks that make it tricky to learn.All about the indexesThe key to understanding ‘route’ is to realize it’s just a way of rearranging vectors using indexing. There are two vectors involved: the original vector and the output vector. The original vector represents the order of the channels at this point in the signal flow. The output vector is the order of the channels from this point forward. The indexing is zero based. The indexes (:0, :1, :2, etc.) represent positions in the original vector. Psuedo example: If there are three channels, [Left Right Sum], going through an algorithm and then ‘route’ is called with mha.route.out = [ :0 :2 :1] then the order of the channels gets changed to [Left Sum Right]Physical input/output indexes(All the examples and explanations here are for the in/out library (iolib) MHAIOalsa. The same basic concepts apply to the Jack iolib, although the nomenclature is different.) Inputs: Signal Index BTE Left Front Mic :0 BTE Right Front Mic :1 Line in Left :2 XXX XXX BTE Left Rear Mic :4 BTE Right Rear Mic :5 Line in Right :6 Outputs: Signal Index BTE Left Receiver :0 BTE Right Receiver :1 Line out Left :2 XXX XXX XXX XXX XXX XXX Line out Right :6 ExamplesIn index.cfg, from the default generic hearing aid configuration that comes with the PHL, the route plugin is used as follows: mha.sort_input.out=[:0 :4 :1 :5 :2 :6] where ‘sort_input’ is an alias for ‘route’. Looking at the indexes for the direct inputs, this results in a vector of signals in the following order: [Left Front Mic, Left Rear Mic, Right Front Mic, Right Rear Mic, Line in Left, Line in Right]The simple_compressor.cfg example only uses two front mics, so the statement mha.sort_input.out = [:0 :1]where ‘sort_input’ is again an alias for ‘route’, results in [Left Front Mic, Right Front Mic]On the output side, the default generic hearing aid configuration has four channels, two for the BTE receivers and two for the line outputs. They’re in the following order as they’re processed by the algorithm: [BTE Left Receiver, BTE Right Receiver, Line Out Left, Line Out Right] Due to the details of the Alsa interface, to send these signals to the proper outputs we need to specify a vector of length 8. The positions in this vector match up with the output table above. This results in: mha.sort_output.out = [:0 :1 :2 X X X :3 X] Here, ‘sort_output’ is an alias for ‘route’. Also, we can’t use an X as shown here for the ‘dummy’ positions, so we use the :0 signal channel as a placeholder that should be harmless (in theory). So the actual statement in the .cfg file is: mha.sort_output.out = [:0 :1 :2 :0 :0 :0 :3 :0 ] So, it’s a little tricky but hopefully it makes sense.As a final example, if you wanted to change the simple_compressor.cfg example so that it used the Line Inputs instead of the BTE mics, you’d change the previous ‘sort_input’ line to: mha.sort_input.out = [:2 :6] to produce the signal vector [Line In Left, Line In Right]" }, { "title": "Mahalia", "url": "/posts/Mahalia/", "categories": "", "tags": "", "date": "2022-10-26 00:00:00 -0400", "snippet": "Mahalia Jackson was an American gospel singer. It’s her birthday today, October 26. The PHL’s main software package is called ‘Mahalia’, after her.Mahalia Jackson in Berlin" }, { "title": "Lower latency configurations", "url": "/posts/Lower-latency-configurations/", "categories": "", "tags": "", "date": "2022-10-17 00:00:00 -0400", "snippet": "The latency, or delay, through the PHL depends on several interrelated parameters. This post shows how latency is affected by changing the configuration of a typical multiband compressor based on Short Term Fourier Transform (STFT) using overlapp and add processing. The ‘simple-compressor.cfg’ program used in other posts is the starting point for the examples here.As described in the documentation for the overlapadd plugin, the signal is windowed then usually zero padded before going through the FFT. The window is advanced by fragment size and the process is repeated.\t\tM: Window size \t\tN: FFT size\t\tP: Frag sizeThe delay due to the signal processing is then M + (N-M)/2 In addition to this delay, there is a significant delay associated with the data buffering of the Linux operating system.In terms of practical implementations, there are some general constraints: The window size M is usually a multiple of the frag size P (P=2*M, P=4*M, etc.) Zero padding is necessary to prevent aliasing in practical systems. This means N&gt;M, and the length of the zero padding limits the length of the impulse response of the effective filter formed by different band gains. The length of the FFT can affect its computational efficiency. It doesn’t need to be a power of two, but it’s probably best to keep it a product of small prime numbers. For example, 2^5 * 3 = 96. At a certain point the CPU will run out of cycles when the configuration as a whole proves too much. Sampling rate, fragment size, FFT size and overall algorithm complexity all play a role here. And of course, a smaller FFT size results in less frequency resolution for a given sample rate (given the usual zero padding caveats). This may or may not be much of an issue, depending on how your bands are structured.Delay examplesThe delay through the PHL was measured for different parameter configurations and the results are shown below. The electronic measurement used a soundcard to generate an impulse that was routed through the PHL using the Line input/output connectors. All of these configurations used the same sampling rate, 24kHz, for ease of comparison.   M N P Delay 1 128 256 64 13ms 2 64 128 32 7ms 3 48 96 24 6ms 4* 110 162 55 10ms Example 1 uses the parameters in the original ‘simple-compressor.cfg’ program. Examples 2 and 3 show how the delay decreases as the FFT size and corresponding parameters are made smaller. Example 4* was measured using the default hearing aid program that comes installed on the PHL.Example 3 was also attempted using a sampling rate of 32kHz and the measured delay was 4.5ms, but the processor couldn’t keep up and this caused a very audible sporadic clicking." }, { "title": "Changing the default program", "url": "/posts/Changing-the-default-program/", "categories": "", "tags": "", "date": "2022-10-06 00:00:00 -0400", "snippet": "The PHL comes installed with a default hearing aid program that runs when the device is powered up. It’s also possible to write a your own default program and this post outlines the steps involved in running a custom configuration.The steps necessary to load the simple compressor example onto the PHL are described here. This is just a step by step description of what’s needed, the reasoning behind these steps can be found in other documents.The following skills are needed to successfully get this example running on the PHL, although the full commands are given here if you’re still learning your way around Linux: Ability to log in remotely to the PHL using ssh and copy files from your host computer to the PHL using scp. Very basic knowledge about navigating around Linux directories once you’re on the PHL (cd, ls, etc.). Use an editor (vi, nano, etc.) to make simple changes to text files on the PHL.Get the example custom .cfg files on your host computer1. The files used in this example, simple_compressor.cfg and eq_gains.cfg, are included here in the appendix and they’re known to work. A simple compressor is set up with appropriate gains for the PHL BTE headset so it’s obvious to hear when the device is running correctly. Download the files to your PC (the host computer).Create the new directory structure on the PHL2. After your host computer is connected to the PHL via WiFi, login to the PHL using ssh (user:mha password: mahalia) and from the directory /etc, create a new directory, mahalia_example. Since /etc belongs to root, use the sudo command mha@mahalia:/etc$ sudo mkdir mahalia_example3. Change the owner of the new directory to user ‘mha’. mha@mahalia:/etc$ sudo chown mha:mha mahalia_example4. Copy the config file from the default /etc/mahalia directory into mahalia_examplemha@mahalia:/etc/mahalia_example$ cp ../mahalia/config .5. Edit the /etc/mahalia_example/config file to make sure the settings are correct for the ALSA based simple_compressor.cfg. The JACK_* settings don’t matter here since this example uses the ALSA interface, but it’s important that NOJACK = 1is set in the config file. Also, it’s easier to debug your programs if initially you set OPENMHA_OPTS=\"–daemon \"6. Create the directory mha_configuration in mahalia_example mha@mahalia:/etc/mahalia_example$ mkdir mha_configuration7. Move the .cfg files from the host computer to the PHL directory /etc/mahalia_example/mha_configuration. Do this from the host computer:user@host:~$scp simple_compress.cfg mha@10.0.0.1:/etc/mahalia_example/mha_configuration user@host:~$scp eq_gains.cfg mha@10.0.0.1:/etc/mahalia_example/mha_configuration8. On the PHL, copy the ‘headsets’ directory (and all its contents) from the default /etc/mahalia directory into mahalia_example.mha@mahalia:/etc/mahalia_example$ cp -r ../mahalia/headsets .Edit mahalia.config9. On the PHL, edit the file /configuration/mahalia.config, adding a new variable mahaliaconfig=example and uncommenting MAHALIA_CONFIG_PREFIX=/etc/mahalia_mha@mahalia:/configuration/mahalia.config# Name of the setup to be used # mahaliaconfig=generic-hearing-aid # mahaliaconfig=calibration mahaliaconfig=example # Prefix used to locate the directory that contains the openMHA configurations and gui setup MAHALIA_CONFIG_PREFIX=/etc/mahalia_ Restart mahalia and run the program10. Restart the mahalia service with the new settingsmha@mahalia:/etc/mahalia_example$ sudo systemctl restart mahalia11. From the host computer, run nc (or ncat)user@host:~$nc 10.0.0.1 33337Hit return to verify you’re in interactive mode (should get ‘success’)12. From interactive mode, read in the new .cfg file ?read:/etc/mahalia/mha_configuration/simple_compressor.cfg Verify no errors, and start cmd=start Verify no errors. You should hear the device running. It’s useful to run a new program this way in the interactive mode because it shows any errors that may occur.If you encounter errors or want to make changes, quit interactive mode. cmd=quit This will take you out of interactive mode. You can edit your .cfg file on the PHL, making any necessary changes, restart interactive mode (step 11), then repeat this step.13. If everything is OK, you can have the program run automatically on startup by editing two files on the PHL. Change the last line of the /etc/mahalia_example/config file: # openMHA settings OPENMHA_INTERFACE=”0.0.0.0” OPENMHA_PORT=”33337” OPENMHA_OPTS=”–daemon ?read:$MHA_CONFIG_PATH/simple_compressor.cfg”Also, add the following as the last line of simple_compressor.cfg (/etc/mahalia_example/mha_configuration/simple_compressor.cfg) cmd = start When you reboot the device, the simple_compressor.cfg program will run automatically.Appendixsimple_compressor.cfgnchannels_in = 2fragsize = 64srate = 24000 iolib = MHAIOalsaio.in.device=hw:0io.out.device=hw:0io.priority=90mhalib = mhachain mha.algos = [ route:sort_input transducers route:sort_output]mha.transducers.plugin_name = mhachain mha.transducers.mhachain.algos = [ overlapadd ]mha.sort_input.out = [:0 :1]mha.sort_output.out = [:0 :1 :0 :0 :0 :0 :1 :0]mha.transducers.calib_in.peaklevel = [115 115]mha.transducers.calib_in.fir = [[1 0 0];[1 0 0]]mha.transducers.calib_out.peaklevel = [ 108]mha.transducers.calib_out.fir = [[]]mha.transducers.calib_out.softclip.tau_attack = 0.002mha.transducers.calib_out.softclip.tau_decay = 0.005mha.transducers.calib_out.softclip.threshold = 0.6mha.transducers.calib_out.softclip.slope = 0.5mha.transducers.calib_out.softclip.tau_clip = 1mha.transducers.calib_out.softclip.max_clipped = 1mha.transducers.calib_out.do_clipping = yes mha.transducers.mhachain.overlapadd.plugin_name = mhachainmha.transducers.mhachain.overlapadd.fftlen = 256mha.transducers.mhachain.overlapadd.wnd.type = hanningmha.transducers.mhachain.overlapadd.wnd.user = []mha.transducers.mhachain.overlapadd.wnd.len = 128mha.transducers.mhachain.overlapadd.wnd.pos = 0.5mha.transducers.mhachain.overlapadd.wnd.exp = 1mha.transducers.mhachain.overlapadd.zerownd.type = rectmha.transducers.mhachain.overlapadd.zerownd.user = []mha.transducers.mhachain.overlapadd.mhachain.algos = [multibandcompressor:mbc equalize]mha.transducers.mhachain.overlapadd.mhachain.mbc.unit = Hzmha.transducers.mhachain.overlapadd.mhachain.mbc.f = [250 500 1000 1500 2000 3000 4000 6000 8000]mha.transducers.mhachain.overlapadd.mhachain.mbc.fscale = logmha.transducers.mhachain.overlapadd.mhachain.mbc.ovltype = hanning mha.transducers.mhachain.overlapadd.mhachain.mbc.ftype = centermha.transducers.mhachain.overlapadd.mhachain.mbc.plugin_name = dc_simple mha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.limiter_threshold = [95 95 95 95 95 95 95 95 95 95 95 95 95 95 95 95 95 95 ] mha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.expansion_slope = [1.5] mha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.tau_attack = [0.005] mha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.tau_decay = [0.015]mha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.filterbank = mbcmha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.g50 = [ 12 12 12 12 12 12 12 12 12 ... 12 12 12 12 12 12 12 12 12]mha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.g80 = [ 12 12 12 12 12 12 12 12 12 ... 12 12 12 12 12 12 12 12 12]mha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.maxgain = [40 40 40 40 40 40 40 40 40 ... 40 40 40 40 40 40 40 40 40 ]mha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.expansion_threshold = [40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40]mha.transducers.mhachain.overlapadd.mhachain.equalize?read:/etc/mahalia/mha_configuration/eq_gains.cfg#cmd=starteq_gains.cfggains = [[ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ]; ... [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ];]" }, { "title": "Simple compressor example", "url": "/posts/Simple-Compressor-Example/", "categories": "", "tags": "", "date": "2022-09-15 00:00:00 -0400", "snippet": "The default program that comes installed on the PHL can be overwhelming for new users trying to understand the openMHA framework. A less complex program is presented here that implements a compressor without any other processing.(If you’re interested in more fully documented openMHA programs, check out the /openMHA/examples directory in your installation. Just remember, most of that code is designed to run on a PC. New users often get confused by openMHA details that don’t translate between PC and PHL.)The configuration files for this Simple Compressor are located at the end of this post and also at https://github.com/BC-support/Simple-Compressor.Signal Flow Only the front mics of the BTEs are used here. The output goes to the respective BTE receivers along with the headphone line out. mha.sort_input.out = [:0 :1]mha.sort_output.out = [:0 :1 :0 :0 :0 :0 :1 :0] The FFT length is 256 samples.mha.transducers.mhachain.overlapadd.fftlen = 256mha.transducers.mhachain.overlapadd.wnd.type = hanningmha.transducers.mhachain.overlapadd.wnd.user = []mha.transducers.mhachain.overlapadd.wnd.len = 128 There are 9 bands in the compressor.mha.transducers.mhachain.overlapadd.mhachain.mbc.f = [250 500 1000 1500 2000 3000 4000 6000 8000] The gain is currently set to 12dB linear.mha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.g50 = [ 12 12 12 12 12 12 12 12 12 ... 12 12 12 12 12 12 12 12 12]mha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.g80 = [ 12 12 12 12 12 12 12 12 12 ... 12 12 12 12 12 12 12 12 12] The EQ stage (equalization) settings are currently flat and are read in from an extenal file. mha.transducers.mhachain.overlapadd.mhachain.equalize?read:/etc/mahalia/mha_configuration/eq_gains.cfg Running the code on the PHLTo run this code on the PHL instead of the default generic hearing aid application a number of changes need to be made to settings and files on the device. It’s not that complicated though, and there will be another blog post detailing the exact steps needed to set up the PHL to run this or any other configuration the user desires.simple-compressor.cfgnchannels_in = 2fragsize = 64srate = 24000 iolib = MHAIOalsaio.in.device=hw:0io.out.device=hw:0io.priority=90mhalib = mhachain mha.algos = [ route:sort_input transducers route:sort_output]mha.transducers.plugin_name = mhachain mha.transducers.mhachain.algos = [ overlapadd ]mha.sort_input.out = [:0 :1]mha.sort_output.out = [:0 :1 :0 :0 :0 :0 :1 :0]mha.transducers.calib_in.peaklevel = [115 115]mha.transducers.calib_in.fir = [[1 0 0];[1 0 0]]mha.transducers.calib_out.peaklevel = [ 108]mha.transducers.calib_out.fir = [[]]mha.transducers.calib_out.softclip.tau_attack = 0.002mha.transducers.calib_out.softclip.tau_decay = 0.005mha.transducers.calib_out.softclip.threshold = 0.6mha.transducers.calib_out.softclip.slope = 0.5mha.transducers.calib_out.softclip.tau_clip = 1mha.transducers.calib_out.softclip.max_clipped = 1mha.transducers.calib_out.do_clipping = yes mha.transducers.mhachain.overlapadd.plugin_name = mhachainmha.transducers.mhachain.overlapadd.fftlen = 256mha.transducers.mhachain.overlapadd.wnd.type = hanningmha.transducers.mhachain.overlapadd.wnd.user = []mha.transducers.mhachain.overlapadd.wnd.len = 128mha.transducers.mhachain.overlapadd.wnd.pos = 0.5mha.transducers.mhachain.overlapadd.wnd.exp = 1mha.transducers.mhachain.overlapadd.zerownd.type = rectmha.transducers.mhachain.overlapadd.zerownd.user = []mha.transducers.mhachain.overlapadd.mhachain.algos = [multibandcompressor:mbc equalize]mha.transducers.mhachain.overlapadd.mhachain.mbc.unit = Hzmha.transducers.mhachain.overlapadd.mhachain.mbc.f = [250 500 1000 1500 2000 3000 4000 6000 8000]mha.transducers.mhachain.overlapadd.mhachain.mbc.fscale = logmha.transducers.mhachain.overlapadd.mhachain.mbc.ovltype = hanning mha.transducers.mhachain.overlapadd.mhachain.mbc.ftype = centermha.transducers.mhachain.overlapadd.mhachain.mbc.plugin_name = dc_simple mha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.limiter_threshold = [95 95 95 95 95 95 95 95 95 95 95 95 95 95 95 95 95 95 ] mha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.expansion_slope = [1.5] mha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.tau_attack = [0.005] mha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.tau_decay = [0.015]mha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.filterbank = mbcmha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.g50 = [ 12 12 12 12 12 12 12 12 12 ... 12 12 12 12 12 12 12 12 12]mha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.g80 = [ 12 12 12 12 12 12 12 12 12 ... 12 12 12 12 12 12 12 12 12]mha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.maxgain = [40 40 40 40 40 40 40 40 40 ... 40 40 40 40 40 40 40 40 40 ]mha.transducers.mhachain.overlapadd.mhachain.mbc.dc_simple.expansion_threshold = [40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40]mha.transducers.mhachain.overlapadd.mhachain.equalize?read:/etc/mahalia/mha_configuration/eq_gains.cfgcmd=starteq_gains.cfggains = [[ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ]; ... [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ];]" } ]
